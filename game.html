<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="style/game.css">
    <link rel="manifest" href="json/manifest.json">
    <link rel="shortcut icon" href="img/logos/favicon.ico" type="image/x-icon">
    <title>Webions</title>
  </head>
  <body>
    <noscript>
      This game will not apear without JavaScript - turn it on to play.
    </noscript>
    <div class="loader">
      <img src="img/logos/logo.webp" alt="Webions Game">
      <h1>WEBIONS</h1>
      <div class="loadDetails"></div>
    </div>
    <div class="wrapper">
      <div class="mobileControls leftPanel"></div>
      <div class="mobileControls rightPanel"></div>
      <div class="gamePlane">
        <canvas ></canvas>  
      </div>
    </div>
  </body>
</html>
<!--| CLEAR OLD CACHE |-->
<script>
  // caches.open('v1').then(function(cache) {
  // cache.delete('/images/image.png').then(function(response) {
  //   someUIUpdateFunction();
  // });
  // })
</script>
<script src="js/functions.js"></script>
<script src="js/sprites.js"></script>
<script src="js/map.js"></script>
<script>const map = new Map();</script>
<script src="js/controls.js"></script>
<!-- POPUP -->
<script>
    const popup = {
    init(title = "GAME STOPPED."){
      this.dom = document.createElement("div");
      this.dom.style.cssText = `
        display:flex;
        flex-direction:column;
        justify-content:center;
        align-items:center;
        width:100%;
        height:100%;
        position:fixed;
        left:0;
        top:0;
        z-index:3;
        `;
        // background-color:rgba(0,0,0,0.8)
      this.h1 = document.createElement("h1");
      this.h1.innerHTML = title;
      this.button = document.createElement("button");
      this.button.style.position = "unset";
      this.button.style.padding = "10px 50px";
      this.button.onclick = () => {window.location.reload();}
      this.button.innerText = " PLAY. ";

      this.dom.append(this.h1);
      this.dom.append(this.button);
      document.body.append(this.dom);
    }
  }
</script>
<!-- PLAYER INIT SETTINGS -->
<script>
  const urlParams = new URLSearchParams(window.location.search);
  let player = {};
  player.name = urlParams.get('player');
  if(player.name == null){
    player.name = "Newbie";
  }
  player.position = [0,0,0];
</script>
<!--| GAMEPLANE PROPERTIES |-->
<script>
  // player.update = () => {}
  let inGameConsole;
  const gamePlane = {
    fps : 10,
    actions: [],
    creatures : {
      list: [],
      ids: []
    },
    sprites: [],
    canvas : document.querySelector(".gamePlane > canvas"),
    init () {
      this.canvas.width = 440;
      this.canvas.height = this.canvas.width;
      this.gridSize = this.canvas.width/11;
      this.context = this.canvas.getContext("2d");
      inGameConsole = new Text();
      this.interval = setInterval(this.updategamePlane, 1000/gamePlane.fps);
      controls.init();
      window.addEventListener('keydown', function (e) {
        controls.update([e.keyCode,true]);
      })
      window.addEventListener('keyup', function (e) {
        controls.update([e.keyCode,false])
      })
    },
    updategamePlane() {
      gamePlane.context.clearRect(0, 0, gamePlane.canvas.width, gamePlane.canvas.height);
      serv.load();
      if(player.type == "player"){ // on serv load player
        player.update();
        map.update([player.newPos[0],player.newPos[1],map.visibleFloor]);
        const drawStack = [];
        // update grids
        for(const g of map.grids){
          g.update();
          drawStack.push(g);
        }
        // update creatures
        for(const c of gamePlane.creatures.list){
          if(c.id != player.id){c.update();}
          drawStack.push(c);
        }
        // sort it in order of rendering.
        drawStack.sort((a,b)=>{
          if(a.position[2] < b.position[2]){
            return -1;
          }else if(a.position[2] == b.position[2]){
            // floors always down.
            if(a.type == "floors"){return -1;}
            // dead body down.
            if(typeof a.health != "undefined" && a.health <= 0 
            && typeof b.health != "undefined"){return -1;}

            if(a.type != "floors" && b.type != "floors"){
              if(a.position[1] < b.position[1]){return -1;}
              if(a.position[0] < b.position[0]){return 1;}
            }


          }

          // stairs and walls 

        })
        // console.log(drawStack);
        // draw all in order
        for(const e of drawStack){
          e.draw();
        }
        for(const a of gamePlane.actions){a.update();}
        inGameConsole.update();
      }
    },
    stop(title = "GAME STOPPED."){
      // show popup
      popup.init(title);
      clearInterval(this.interval);
      console.log("Game stopped.")
    }
  }
</script>
<script src="js/components.js"></script>
<!--| WEBSOCKET SERVER CONNECTION |-->
<script>
  const serv = {
    init(){
      (window.location.protocol == "https:")?this.protocol = "wss:":this.protocol = "ws:";
      this.ws = new WebSocket(this.protocol+"//"+window.location.host+"/fetch/?name="+urlParams.get('player'),'echo-protocol');
      this.ws.onopen = () => {this.connected = true;console.log("WS open.");}
    },
    connected:false,
    param : {},
    paramUpdate(){
      this.param.name = urlParams.get('player');
      this.param.id = false;
      this.param.controls = controls.vals;
      isSet(player.whiteTarget)?this.param.target = player.whiteTarget:'';
      return this.param;
    },
    load(){
      // set connection
      this.ws.onclose = () => {
        this.connected = false;console.log("WS closed.");
        let newURL = window.location.origin+"/offline.html?reason=servErr&back=";
        newURL += encodeURIComponent(window.location.href);
        // console.log(newURL)
        window.location.replace(newURL);
      }
      // send to server
      if(this.connected){
        // console.log(this.param.id);
        this.ws.send(JSON.stringify(this.paramUpdate()));
      }
      // get response
      this.ws.onmessage = (msg) => {
        const data = JSON.parse(msg.data);
        // player died
        if(typeof data.game.dead != "undefined"){
          gamePlane.stop("You are dead.");
        }

        // update game properties
        this.datetime = data.game.time;
        this.time = new Date(this.datetime).getTime();
        gamePlane.fps = data.game.fps;
        // get names of online players
        let onlinePlayers = [];
        for(const p of data.creatures){
          if(p.type == "player"){
            onlinePlayers.push(p.name);
          }
        }

        // kick off offline players and update creature names
        for(const ac of gamePlane.creatures.list){
          if(!onlinePlayers.includes(ac.name) && ac.type == "enemy"){
            gamePlane.actions.push(new Action("misc",ac.position[0]+ac.x,ac.position[1]+ac.y,40,40,0));     
            gamePlane.creatures.list.splice(gamePlane.creatures.list.indexOf(ac),1);
            if(gamePlane.creatures.ids.includes(ac.id)){
              gamePlane.creatures.ids.splice(gamePlane.creatures.ids.indexOf(ac.id),1);
            }
            continue;
          }
          if(!gamePlane.creatures.ids.includes(ac.id)){
            gamePlane.creatures.ids.push(ac.id);
          }
        }
        
        // updating values
        for(const creature of data.creatures){
          let myChar;
          let charId;
          if(!gamePlane.creatures.ids.includes(creature.id)){
            if(creature.name == urlParams.get('player')){
              player = new Creature("player",player.position,urlParams.get('player')); 
              myChar = player;
            }else{
              let type = "monster";
              if(creature.type == "player"){type = "enemy";}
              myChar = new Creature(type,creature.position,creature.name);
            }
            gamePlane.creatures.list.push(myChar);
            charId = gamePlane.creatures.list.length-1;
            // charId = myChar.id;
          }else{
            // find it in gamePlane.creatures.list
            for(const [i,pl] of gamePlane.creatures.list.entries()){
              if(pl.id == creature.id){
                myChar = creature;
                charId = i;
              }
            }
            // update console
            if(creature.name == player.name && creature.text != ""){
              inGameConsole.text = creature.text;
              // console.log(creature.text);
            }
          }
          // updating values
          for(const key of Object.keys(creature)){
            if(key == "position"){
              if(!compareTables(gamePlane.creatures.list[charId]["newPos"],creature[key])){
                gamePlane.creatures.list[charId]["oldPos"] = gamePlane.creatures.list[charId]["newPos"];
                gamePlane.creatures.list[charId]["newPos"] = creature[key];
                gamePlane.creatures.list[charId]["walkingStart"] = serv.time;
              }
              continue;
            }
            if(key == "health"){gamePlane.creatures.list[charId]["oldHealth"] = gamePlane.creatures.list[charId]["health"];}
            if(key == "skills"){
              let oldExp;
              let oldLvl;
              if(gamePlane.creatures.list[charId].type == "player"
              && isSet(gamePlane.creatures.list[charId].skills)){
                if(gamePlane.creatures.list[charId].skills["exp"] != creature[key]["exp"]){
                  oldExp = gamePlane.creatures.list[charId].skills["exp"];
                }
                if(gamePlane.creatures.list[charId].skills["level"] != creature[key]["level"]){
                  oldLvl = gamePlane.creatures.list[charId].skills["level"];                  
                }
              }
              gamePlane.creatures.list[charId].skills = {};
              for(const k of Object.keys(creature[key])){
                if(k == "exp" && isSet(oldExp)){
                  gamePlane.creatures.list[charId].skills["oldExp"] = oldExp;
                }
                if(k == "level" && isSet(oldLvl)){
                  gamePlane.creatures.list[charId].skills["oldLvl"] = oldLvl;
                }
                gamePlane.creatures.list[charId].skills[k] = creature[key][k];
              }
              if(!isSet(oldExp)){gamePlane.creatures.list[charId].skills["oldExp"] = gamePlane.creatures.list[charId].skills["exp"];}
              if(!isSet(oldLvl)){gamePlane.creatures.list[charId].skills["oldLvl"] = gamePlane.creatures.list[charId].skills["level"];}
              continue;
            }
            // if(key == "shotPosition"){
            //   gamePlane.creatures.list[charId].lastShotPosition = gamePlane.creatures.list[charId].shotPosition;
            //   gamePlane.creatures.list[charId].shotPosition = creature.shotPosition;
            //   continue;
            // }
            if(key == "type"){continue;}
            gamePlane.creatures.list[charId][key] = creature[key];
          }
        }

        // show dev info
        // dev.stats = data.game;
        dev.stats.time = serv.time;
        dev.stats.player = player.name;
        dev.stats.health = player.health;
        dev.stats.position = player.position;
        dev.stats.grids = map.grids.length;
        dev.stats.url = urlParams.get('player');
        dev.stats.ping = this.time - player.lastFrame;
        dev.stats.cpu = data.game.cpu;
        // dev.stats.ws = JSON.stringify(gamePlane.creatures.list);
        dev.update();
        
        /* 
        new version
        // console.log("get.");
        const data = JSON.parse(msg.data);
        this.datetime = data.game.time;
        this.time = new Date(data.game.time).getTime();
        gamePlane.fps = data.game.fps;
        
        

        // get names of online players for kicking offlines
        let onlinePlayers = [];
        for(const p of data.creatures){
          if(p.type == "player"){
            onlinePlayers.push(p.name);
          }
        }
        // kick off offline players and update creature names
        for(const ac of gamePlane.creatures.list){
          if(!onlinePlayers.includes(ac.name) && ac.type == "enemy"){
            gamePlane.actions.push(new Action("misc",ac.position[0]+ac.x,ac.position[1]+ac.y,40,40,0));     
            gamePlane.creatures.list.splice(gamePlane.creatures.list.indexOf(ac),1);
            if(gamePlane.creatures.ids.includes(ac.id)){
              gamePlane.creatures.ids.splice(gamePlane.creatures.ids.indexOf(ac.id),1);
            }
            continue;
          }
          if(!gamePlane.creatures.ids.includes(ac.id)){
            gamePlane.creatures.ids.push(ac.id);
          }
        }
        
        // updating values
        for(const creature of data.creatures){
          let isOnList = false;
          for(const cfromList of gamePlane.creatures.list){
            if(cfromList.id == creature.id){
              isOnList = true;
              // console.log(cfromList.name);
              // update values
              for(const key of Object.keys(creature)){
                if(key == "position"){
                  if(!compareTables(cfromList["newPos"],creature[key])){
                    cfromList["oldPos"] = cfromList["newPos"];
                    cfromList["newPos"] = creature[key];
                    cfromList["walkingStart"] = serv.time;
                    // gamePlane.creatures.list[charId]["oldPos"] = gamePlane.creatures.list[charId]["newPos"];
                    // gamePlane.creatures.list[charId]["newPos"] = creature[key];
                    // gamePlane.creatures.list[charId]["walkingStart"] = serv.time;
                  }
                  continue;
                }
                if(key == "health"){
                  cfromList["oldHealth"] = cfromList["health"];
                  // gamePlane.creatures.list[charId]["oldHealth"] = gamePlane.creatures.list[charId]["health"];
                }
                // probably problematically
                // if(key == "skills"){
                //   let oldExp;
                //   let oldLvl;
                //   if(cfromList["type"] == "player"
                //   && isSet(cfromList["skills"])){
                //     if(cfromList.skills["exp"] != creature[key]["exp"]){
                //       oldExp = cfromList.skills["exp"];
                //     }
                //     if(cfromList.skills["level"] != creature[key]["level"]){
                //       oldLvl = cfromList.skills["level"];
                //     }
                //   }
                  
                //   cfromList.skills = {};
                //   for(const k of Object.keys(creature[key])){
                //     if(k == "exp" && isSet(oldExp)){
                //       cfromList.skills["oldExp"] = oldExp;
                //     }
                //     if(k == "level" && isSet(oldLvl)){
                //       cfromList.skills["oldExp"] = oldExp;
                //     }
                //     cfromList.skills[k] = creature[key][k];
                //   }
                //   if(!isSet(oldExp)){cfromList.skills["oldExp"] = cfromList.skills["exp"]}
                //   if(!isSet(oldLvl)){cfromList.skills["oldLvl"] = cfromList.skills["level"]}
                // }               
                
                if(key == "shotPosition"){
                  cfromList["lastShotPosition"] = cfromList["shotPosition"];
                  cfromList["shotPosition"] = creature.shotPosition;
                  // gamePlane.creatures.list[charId].lastShotPosition = gamePlane.creatures.list[charId].shotPosition;
                  // gamePlane.creatures.list[charId].shotPosition = creature.shotPosition;
                  continue;
                }
                if(key == "type"){continue;}
                cfromList[key] = creature[key];
              }
              // console.log(cfromList);
            }
            // console.log(cfromList.id);
            // console.log(data.game.player);
            if(cfromList.id == data.game.player){
                player = cfromList;

                // console.log(player);
              }

          }
          if(!isOnList){
            gamePlane.creatures.list.push(new Creature(creature.type,creature.position,creature.name,creature.id));
          }




          // end of new way


          // let charId; 
          // if(!gamePlane.creatures.ids.includes(creature.id)){
          //   let newChar;
          //   // if not exsists - create it. 
          //   if(creature.id == data.game.player){
          //     player = new Creature("player",player.position,urlParams.get('player')); 
          //     newChar = player;
          //   }else{
          //     let type;(creature.type == "player")?type = "enemy":type = "monster";
          //     newChar = new Creature(type,creature.position,creature.name);
          //   }
          //   gamePlane.creatures.list.push(newChar);
          // }else{
          //   // find it in gamePlane.creatures.list
          //   // for(const [i,pl] of gamePlane.creatures.list.entries()){
          //   //   if(pl.id == creature.id){
          //   //     myChar = creature;
          //   //     // charId = i;
          //   //   }
          //   // }
          //   // update console
          //   if(creature.id == data.game.player && creature.text != ""){
          //     inGameConsole.text = creature.text;
          //   }
          // }
        }
      
        // callback(data)

        // must be on the end.
        dev.stats = data.game;
        dev.stats.player = player.name;
        dev.stats.position = player.position;
        dev.stats.grids = map.grids.length;
        dev.stats.url = urlParams.get('player');
        dev.stats.ping = this.time - player.lastFrame;
        // dev.stats.ws = JSON.stringify(gamePlane.creatures.list);
        dev.update(); // */
      }
      // connection error
      this.ws.onerror = (error) => {
        gamePlane.stop();
        // console.log("Your connection is lost, ");
        console.log(error);
      }
    }
  }
  serv.init();
</script>
<!--| PRELOAD |-->
<script>
  // preload ;>
  document.querySelector(".loadDetails").innerHTML = "Load sprites ...";
  map.loadSprites(()=>{
    serv.load();
    document.querySelector(".loadDetails").innerHTML = "Load map ...";
    map.generate(()=>{
      document.querySelector(".loadDetails").innerHTML = "Load game plane ...";
      gamePlane.init();
      document.querySelector(".loader").style.display = "none";
    })
  })
  // set elements resolution:
  mobileControls.preventZoom();
  setResolution();
  window.onresize = () =>{
    setResolution();  
  }
</script>
<!--| SERVICE WORKER FOR OFFLINE DISPLAY |-->
<script>
  if('serviceWorker' in navigator) {
    // serviceWorkerRegistration.update();
    navigator.serviceWorker.register('serviceWorker.js'
    , {scope: 'serviceWorker'}).then(function(registration) {
      registration.update();
    });
  }
  
</script>
<!--| DEVELOPER BUTTONS & STATS |-->
<script>
  const dev = {
    buttonIndex : 0,
    init(){
      this.makeDevButt("STOP",()=>{gamePlane.stop()});
      this.makeDevButt("UPDATE",()=>{gamePlane.updategamePlane()});
      // this.makeDevButt("START",()=>{gamePlane.init()});
      this.makeStatsField();
      this.update();
    },
    makeDevButt(title,func){
      const butt = document.createElement("button");
      butt.onclick = () => { func()};
      butt.innerHTML =  title;
      butt.style.zIndex = 4;
      document.body.append(butt);
      butt.style.marginTop = ((butt.clientHeight+10)*this.buttonIndex)+ "px";
      this.buttonIndex++;
    },
    makeStatsField(){
      this.statsDOM = document.createElement("div");
      this.statsDOM.innerHTML = "ELO :D"
      this.statsDOM.style.cssText = `
        width:30vw;
        position:fixed;
        right:0;
        top:0;
        padding:2%;
        font-size:0.6em;
        color:#000;
        background-color:rgba(255,255,255,0.8)
        `;
      document.body.append(this.statsDOM);
    },
    stats : {
      fps: 10,
      player: player.name
    },
    update(){
      if(typeof this.statsDOM != "undefined"){
        this.statsDOM.innerHTML = "";
        for(const s of Object.keys(this.stats)){
          if(s == "time"){
            const t = new Date(this.stats[s]);
            const time = t.getHours()+":"+t.getMinutes()+":"+t.getSeconds();
            this.statsDOM.innerHTML += s +": "+time+"<br />";    
            continue;
          }
          this.statsDOM.innerHTML += s +": "+this.stats[s]+"<br />";
        }
      }
    }
  } 
  if(urlParams.get("dev") == "on"){
    dev.init();
  }
</script>