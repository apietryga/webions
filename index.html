<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="style/style.css">
  <link rel="manifest" href="json/manifest.json">
  <link rel="shortcut icon" href="img/logos/favicon.ico" type="image/x-icon">
  <title>Webions</title>
</head>
<body>
  <noscript>
    This game will not apear without JavaScript - turn it on to play.
  </noscript>
  <div class="loader">
    <img src="img/logos/logo.webp" alt="Webions Game">
    <h1>LOADING</h1>
    <div class="loadDetails"></div>
  </div>
  <div class="wrapper">
    <div class="mobileControls leftPanel"></div>
    <div class="mobileControls rightPanel"></div>
    <div class="gamePlane">

      <canvas ></canvas>  
    </div>
  </div>

  <!-- DEV BUTTONS -->
  <button onclick="gamePlane.stop()">STOP</button>
  <button onclick="gamePlane.init()">START</button>

  <script src="js/components.js"></script>
  <script src="js/functions.js"></script>
  <script src="js/mapcontroller.js"></script>
  <script src="js/sprites.js"></script>
  <script src="js/controls.js"></script>
</body>
</html>
<!--| GAME PROPERTIES |-->
<script>
  const urlParams = new URLSearchParams(window.location.search);
  let playerName = urlParams.get('player');
  if(playerName == null){
    playerName = "Newbie";
  }
  let inGameConsole;
  let player;
  const gamePlane = {
    fps : 10,
    actions: [],
    floors: [-1,0,1,2],
    creatures : {
      list: [],
      names: []
    },
    sprites: [],
    canvas : document.querySelector(".gamePlane > canvas"),
    init () {
      this.canvas.width = 440;
      this.canvas.height = this.canvas.width;
      this.gridSize = 40;
      this.context = this.canvas.getContext("2d");
      inGameConsole = new Text();
      this.interval = setInterval(this.updategamePlane, 1000/gamePlane.fps);
      controls.init();
      window.addEventListener('keydown', function (e) {
        controls.update([e.keyCode,true]);
        // gamePlane.key = e.keyCode;
      })
      window.addEventListener('keyup', function (e) {
        controls.update([e.keyCode,false])
        // gamePlane.key = false;
      })
    },
    clear() {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    },
    loadSprites(callback) {
      for(const s of sprites){
          this.sprites[s.name] = document.createElement("img");
          this.sprites[s.name].src = s.src;
      }
      callback();
    },
    updategamePlane() {
      gamePlane.clear();
      map.update();     
      serv.load();
      let player = false;
      for(const ac of gamePlane.creatures.list){
        if(ac.name == playerName){
          player = ac;
          continue;
        }
        ac.update();
      }
      if(player){
        player.update();
        for(const f of gamePlane.floors){
          map.draw(f);
          for(const ac of gamePlane.creatures.list){
            ac.draw(f);
          }
          player.draw(f);
        }
        for(const a of gamePlane.actions){a.update();}
        inGameConsole.update();
      }
    },
    stop(){
      clearInterval(this.interval);
      console.log("Game stopped.")
    }
  }
</script>

<!--| WEBSOCKET SERVER CONNECTION |-->
<script>
  const ws = new WebSocket("ws://"+window.location.host+"/fetch/?name="+playerName,'echo-protocol');
  const serv = {
    connected:false,
    load(){
      // set connection
      ws.onopen = () => {this.connected = true;}
      ws.onclose = () => {this.connected = false;}
      // send to server
      if(this.connected){
        const param = {
          "name":playerName,
          "controls":controls.vals
        };
        ws.send(JSON.stringify(param));
      }
      // get response
      ws.onmessage = (msg) => {
        // console.log(JSON.parse(msg.data));
        const data = JSON.parse(msg.data);
        // console.log(data.creatures[0].walk);
        // console.log(data.game.time);
        // set game properties
        this.datetime = data.game.time;
        this.time = new Date(data.game.time).getTime();
        gamePlane.fps = data.game.fps;
        // updating names and online/offline players
        for(const ac of gamePlane.creatures.list){
          if(!gamePlane.creatures.names.includes(ac.name)){
            gamePlane.creatures.names.push(ac.name);
          }
        }
        // updating values
        for(const creature of data.creatures){
          let myChar;
          let charId;
          if(!gamePlane.creatures.names.includes(creature.name)){
            if(creature.name == playerName){
              player = new Creature("player",2,3,0,playerName); 
              myChar = player;
            }else{
              myChar = new Creature("enemy",creature.position[0],creature.position[1],creature.position[2],creature.name);
            }
            gamePlane.creatures.list.push(myChar);
            charId = gamePlane.creatures.list.length-1;
          }else{
            // find it in gamePlane.creatures.list
            for(const [i,pl] of gamePlane.creatures.list.entries()){
              if(pl.name == creature.name){
                myChar = creature;
                charId = i;
              }
            }
            // update console
            if(creature.name == playerName && creature.text != ""){
              inGameConsole.text = creature.text;
              // console.log(creature.text);
            }
          }
          // updating values
          for(const key of Object.keys(creature)){
            if(key == "position"){
              if(!compareTables(gamePlane.creatures.list[charId]["newPos"],creature[key])){
                gamePlane.creatures.list[charId]["oldPos"] = gamePlane.creatures.list[charId]["newPos"];
                gamePlane.creatures.list[charId]["newPos"] = creature[key];
                gamePlane.creatures.list[charId]["walkingStart"] = serv.time;
              }
              continue;
            }
            if(key == "health"){gamePlane.creatures.list[charId]["oldHealth"] = gamePlane.creatures.list[charId]["health"];}
            if(key == "shotPosition"){
              gamePlane.creatures.list[charId].lastShotPosition = gamePlane.creatures.list[charId].shotPosition;
              gamePlane.creatures.list[charId].shotPosition = creature.shotPosition;
              continue;
            }
            if(key == "type"){continue;}
            gamePlane.creatures.list[charId][key] = creature[key];
          }
        }
      }
      // connection error
      ws.onerror = (error) => {
        gamePlane.stop();
        // console.log("Your connection is lost, ");
        console.log(error);
      }
    }
  }

</script>

<!--| PRELOAD |-->
<script>
  // preload ;>
  document.querySelector(".loadDetails").innerHTML = "Load sprites ...";
  gamePlane.loadSprites(()=>{
    serv.load();
    document.querySelector(".loadDetails").innerHTML = "Load map ...";
    map.generate(()=>{
      document.querySelector(".loadDetails").innerHTML = "Load game plane ...";
      gamePlane.init();
      document.querySelector(".loader").style.display = "none";
    })
  })
  // set elements resolution:
  mobileControls.preventZoom();
  setResolution();
  window.onresize = () =>{
    setResolution();  
  }
</script>

<!--| SERVICE WORKER FOR OFFLINE DISPLAY |-->
<script>
  if('serviceWorker' in navigator) {
    navigator.serviceWorker.register('serviceWorker.js');
  }
</script>