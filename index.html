<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="style/style.css">
  <link rel="manifest" href="json/manifest.json">
  <title>TBWeb.</title>
</head>
<body>
  <div class="mobileControls leftPanel"></div>
  <div class="mobileControls rightPanel"></div>
  <canvas class="gamePlane"></canvas>

  <!-- DEV BUTTONS -->
  <button onclick="gamePlane.stop()"
    style='width:50px;
    height:15px;font-size:10px;position:fixed;'
  >STOP</button>
  <button onclick="gamePlane.init()"
    style='width:50px;
    height:15px;font-size:10px;position:fixed;top:20px;'
  >START</button>

  <script src="js/components.js"></script>
  <script src="js/functions.js"></script>
  <script src="js/mapcontroller.js"></script>
  <script src="js/sprites.js"></script>
  <script src="js/controls.js"></script>
</body>
</html>
<!--| GAME PROPERTIES |-->
<script>
  const urlParams = new URLSearchParams(window.location.search);
  let playerName = urlParams.get('player');
  if(playerName == null){
    playerName = "Newbie";
  }
  let inGameConsole;
  let player;
  const gamePlane = {
    fps : 10,
    actions: [],
    floors: [-1,0,1,2],
    creatures : {
      list: [],
      names: []
    },
    sprites: [],
    canvas : document.querySelector(".gamePlane"),
    init () {
      this.canvas.width = 440;
      this.canvas.height = this.canvas.width;
      this.gridSize = 40;
      this.context = this.canvas.getContext("2d");
      inGameConsole = new Text();
      this.interval = setInterval(this.updategamePlane, 1000/gamePlane.fps);
      controls.init();
      window.addEventListener('keydown', function (e) {
        controls.update([e.keyCode,true]);
        // gamePlane.key = e.keyCode;
      })
      window.addEventListener('keyup', function (e) {
        controls.update([e.keyCode,false])
        // gamePlane.key = false;
      })
    },
    clear() {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    },
    loadSprites(callback) {
      for(const s of sprites){
          this.sprites[s.name] = document.createElement("img");
          this.sprites[s.name].src = s.src;
      }
      callback();
    },
    updategamePlane() {
      gamePlane.clear();
      map.update();     
      serv.load();
      let player;
      for(const ac of gamePlane.creatures.list){
        if(ac.name == playerName){
          player = ac;
          continue;
        }
        ac.update();
      }
      player.update();
      for(const f of gamePlane.floors){
        map.draw(f);
        for(const ac of gamePlane.creatures.list){
          ac.draw(f);
        }
        player.draw(f);
      }
      for(const a of gamePlane.actions){a.update();}
      inGameConsole.update();
    },
    stop(){
      clearInterval(this.interval);
      console.log("Game stopped.")
    }
  }
</script>

<!--| SERWER CONNECTION |-->
<script>
  // let allCreatures = [];
  const serv = {
    load(url = ""){
      // send target options
      // if(typeof player != "undefined" && player.isTarget && player.sendTarget){
      if(typeof player != "undefined" && player.redTarget){
        // url += "&redTarget="+player.isTarget;
        url += "&redTarget="+player.redTarget;
      }
      // send controls
      url += "&controls="+controls.vals;     
      fetch(window.location.origin+"/fetch/?name="+playerName+url).then((dt) => dt.json()).then((data) => {
        // set game properties
        this.datetime = data.game.time;
        this.time = new Date(data.game.time).getTime();
        gamePlane.fps = data.game.fps;
        // updating names and online/offline players
        for(const ac of gamePlane.creatures.list){
          if(!gamePlane.creatures.names.includes(ac.name)){
            gamePlane.creatures.names.push(ac.name);
          }
        }
        // updating values
        for(const creature of data.creatures){
          let myChar;
          let charId;
          if(!gamePlane.creatures.names.includes(creature.name)){
            if(creature.name == playerName){
              player = new Creature("player",2,3,0,playerName); 
              myChar = player;
            }else{
              myChar = new Creature("enemy",creature.position[0],creature.position[1],creature.position[2],creature.name);
            }
            gamePlane.creatures.list.push(myChar);
            charId = gamePlane.creatures.list.length-1;
          }else{
            // find it in gamePlane.creatures.list
            for(const [i,pl] of gamePlane.creatures.list.entries()){
              if(pl.name == creature.name){
                myChar = creature;
                charId = i;
              }
            }
            // update console
            if(creature.name == playerName && creature.text != ""){
              inGameConsole.text = creature.text;
              // console.log(creature.text);
            }

          }
          // updating values
          for(const key of Object.keys(creature)){
            if(key == "position"){
              if(!compareTables(gamePlane.creatures.list[charId]["newPos"],creature[key])){
                gamePlane.creatures.list[charId]["oldPos"] = gamePlane.creatures.list[charId]["newPos"];
                gamePlane.creatures.list[charId]["newPos"] = creature[key];
                gamePlane.creatures.list[charId]["walkingStart"] = serv.time;
              }
              continue;
            }
            if(key == "health"){gamePlane.creatures.list[charId]["oldHealth"] = gamePlane.creatures.list[charId]["health"];}
            if(key == "type"){continue;}
            gamePlane.creatures.list[charId][key] = creature[key];
          }
        }
      }).catch((error)=>{
        gamePlane.stop();
        // console.log("Your connection is lost, ");
        console.log(error);
      })
    }
  }
</script>

<!--| PRELOAD |-->
<script>
  // preload ;>
  gamePlane.loadSprites(()=>{
    serv.load();
    console.log("Loaded.")
    map.generate(()=>{
      console.log("Generated.")
      gamePlane.init();
    })
  })
  // set elements resolution:
  mobileControls.preventZoom();
  setResolution();
  window.onresize = () =>{
    setResolution();  
  }
</script>